import { GoogleGenerativeAI } from '@google/generative-ai';
import sharp from 'sharp';
import path from 'path';
import fs from 'fs';

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY || '');

const OUTPUT_DIR = path.join(process.cwd(), 'public', 'generated');

// Ensure output directory exists
if (!fs.existsSync(OUTPUT_DIR)) {
    fs.mkdirSync(OUTPUT_DIR, { recursive: true });
}

/**
 * Generate an image using Gemini's native image generation,
 * then composite the project logo onto it.
 */
export async function generateImageForContent(
    imagePrompt: string,
    contentId: string,
    projectLogo?: string, // base64 data URL
    contentType: string = 'brand'
): Promise<string> {
    let baseImageBuffer: Buffer;

    try {
        // Try Gemini native image generation
        baseImageBuffer = await generateWithGemini(imagePrompt);
    } catch (error) {
        console.log('Gemini image gen failed, creating gradient fallback:', error);
        // Fallback: create a beautiful gradient image
        baseImageBuffer = await createGradientImage(contentType, imagePrompt);
    }

    // Resize base image to standard social media size (1200x630)
    let composited = sharp(baseImageBuffer)
        .resize(1200, 630, { fit: 'cover' });

    // Composite the project logo if available
    if (projectLogo) {
        try {
            const logoBuffer = await prepareLogo(projectLogo);
            composited = composited.composite([
                {
                    input: logoBuffer,
                    gravity: 'southeast',
                    blend: 'over',
                },
            ]);
        } catch (logoErr) {
            console.log('Logo compositing skipped:', logoErr);
        }
    }

    // Save to file
    const filename = `${contentId}.png`;
    const filepath = path.join(OUTPUT_DIR, filename);
    await composited.png().toFile(filepath);

    return `/generated/${filename}`;
}

/**
 * Use Gemini 2.0 Flash Exp for native image generation
 */
async function generateWithGemini(prompt: string): Promise<Buffer> {
    const model = genAI.getGenerativeModel({
        model: 'gemini-2.0-flash-exp-image-generation',
        generationConfig: {
            responseModalities: ['TEXT', 'IMAGE'],
        } as Record<string, unknown>,
    });

    const result = await model.generateContent(
        `Generate a professional, visually stunning social media graphic for: ${prompt}. 
        Make it modern, high-quality, suitable for a tech startup. 
        Use vibrant colors and clean design. Do NOT include any text in the image.`
    );

    const response = result.response;
    const parts = response.candidates?.[0]?.content?.parts || [];

    for (const part of parts) {
        // Check for inline image data
        if (part.inlineData && part.inlineData.data) {
            return Buffer.from(part.inlineData.data, 'base64');
        }
    }

    throw new Error('No image generated by Gemini');
}

/**
 * Create a beautiful gradient background as fallback
 */
async function createGradientImage(
    contentType: string,
    _prompt: string
): Promise<Buffer> {
    // Different color schemes per content type
    const schemes: Record<string, { from: string; to: string; accent: string }> = {
        meme: { from: '#ff6b6b', to: '#feca57', accent: '#ff9ff3' },
        feature: { from: '#6c5ce7', to: '#a29bfe', accent: '#74b9ff' },
        brand: { from: '#00cec9', to: '#0984e3', accent: '#6c5ce7' },
    };
    const scheme = schemes[contentType] || schemes.brand;

    // Create an SVG gradient with decorative elements
    const svg = `
    <svg width="1200" height="630" xmlns="http://www.w3.org/2000/svg">
      <defs>
        <linearGradient id="bg" x1="0%" y1="0%" x2="100%" y2="100%">
          <stop offset="0%" style="stop-color:${scheme.from};stop-opacity:1" />
          <stop offset="100%" style="stop-color:${scheme.to};stop-opacity:1" />
        </linearGradient>
        <radialGradient id="glow1" cx="25%" cy="35%" r="40%">
          <stop offset="0%" style="stop-color:${scheme.accent};stop-opacity:0.3" />
          <stop offset="100%" style="stop-color:${scheme.accent};stop-opacity:0" />
        </radialGradient>
        <radialGradient id="glow2" cx="75%" cy="70%" r="35%">
          <stop offset="0%" style="stop-color:white;stop-opacity:0.15" />
          <stop offset="100%" style="stop-color:white;stop-opacity:0" />
        </radialGradient>
      </defs>
      <rect width="1200" height="630" fill="url(#bg)" />
      <rect width="1200" height="630" fill="url(#glow1)" />
      <rect width="1200" height="630" fill="url(#glow2)" />
      <!-- Decorative circles -->
      <circle cx="150" cy="100" r="80" fill="white" opacity="0.05" />
      <circle cx="1050" cy="530" r="120" fill="white" opacity="0.05" />
      <circle cx="600" cy="315" r="200" fill="white" opacity="0.03" />
      <!-- Grid pattern -->
      <line x1="0" y1="210" x2="1200" y2="210" stroke="white" stroke-opacity="0.05" stroke-width="1" />
      <line x1="0" y1="420" x2="1200" y2="420" stroke="white" stroke-opacity="0.05" stroke-width="1" />
      <line x1="400" y1="0" x2="400" y2="630" stroke="white" stroke-opacity="0.05" stroke-width="1" />
      <line x1="800" y1="0" x2="800" y2="630" stroke="white" stroke-opacity="0.05" stroke-width="1" />
      <!-- Floating dots -->
      <circle cx="200" cy="200" r="4" fill="white" opacity="0.2" />
      <circle cx="350" cy="450" r="3" fill="white" opacity="0.15" />
      <circle cx="700" cy="150" r="5" fill="white" opacity="0.2" />
      <circle cx="900" cy="350" r="3" fill="white" opacity="0.15" />
      <circle cx="1100" cy="200" r="4" fill="white" opacity="0.2" />
      <circle cx="500" cy="500" r="6" fill="white" opacity="0.1" />
    </svg>`;

    return sharp(Buffer.from(svg)).png().toBuffer();
}

/**
 * Prepare the project logo for compositing
 * - Extract from base64 data URL
 * - Resize to appropriate size
 * - Add rounded corners and padding
 * - Add subtle background for visibility
 */
async function prepareLogo(logoDataUrl: string): Promise<Buffer> {
    // Extract raw base64 from data URL
    const base64Data = logoDataUrl.replace(/^data:image\/\w+;base64,/, '');
    const logoBuffer = Buffer.from(base64Data, 'base64');

    const size = 80;
    const padding = 12;
    const totalSize = size + padding * 2;

    // Resize the logo
    const resizedLogo = await sharp(logoBuffer)
        .resize(size, size, { fit: 'contain', background: { r: 0, g: 0, b: 0, alpha: 0 } })
        .png()
        .toBuffer();

    // Create a rounded background
    const roundedBg = Buffer.from(`
        <svg width="${totalSize}" height="${totalSize}">
            <rect x="0" y="0" width="${totalSize}" height="${totalSize}" 
                  rx="16" ry="16" fill="rgba(0,0,0,0.5)" />
        </svg>
    `);

    // Composite logo onto rounded background with padding
    return sharp(roundedBg)
        .composite([
            {
                input: resizedLogo,
                top: padding,
                left: padding,
            },
        ])
        .png()
        .toBuffer();
}
